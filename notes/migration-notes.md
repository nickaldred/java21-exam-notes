# JPMS Migratioon Notes

## One-liners

- **Bottom‑up:** App stays in the unnamed module on the class path; libraries move first to the module path as automatic, then named, modules.  
- **Top‑down:** Main app becomes a named module on the module path early; its dependencies follow later, starting as automatic and then named modules.

## Descriptions

### Bottom-up modular migration

In a bottom-up JPMS migration, the main application generally remains on the class path in the unnamed module while you first modularise the lower layers. You start by moving libraries and shared components to the module path, where they initially act as automatic modules (ordinary JARs without `module-info` that are treated as modules exporting all their packages and reading all other modules). Over time, you add `module-info.java` to these libraries so they become proper named modules. Throughout this phase you typically run with both a class path (for the app / legacy code) and a module path (for libraries), and only once the foundational modules are stable do you convert the main application itself into a named module on the module path.

### Top-down modular migration

In a top-down JPMS migration, you begin by modularising the main application and running it as a named module on the module path (using `module-info.java` and `java -m`). Many of its dependencies are still non-modular, so you place their JARs on the module path as automatic modules, or temporarily leave some legacy code on the class path in the unnamed module. The modularised app explicitly `requires` these automatic (or later, named) modules, and you progressively push modularisation downwards into services, repositories, and libraries by adding `module-info.java` to them. Over time, more of the codebase moves from the unnamed module and automatic modules to fully named modules on the module path.

| Topic                             | Bottom-Up Modular Migration                                                                                                         | Top-Down Modular Migration                                                                                                               |
|-----------------------------------|-------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------|
| Starting point                    | App stays on **class path** (in the **unnamed module**)                                                                             | App quickly becomes a **named module on module path**                                                                                    |
| Main idea                         | Modularise **low-level libraries and infrastructure first**, then the app                                                           | Modularise the **main application first**, then push modularisation into dependencies                                                   |
| Class path / unnamed module use   | **Main app** runs from class path → **unnamed module**; it uses modules on module path                                              | Unnamed module used only for **leftover legacy code**; main app itself **not** in unnamed module                                         |
| Module path use                   | Initially for **libraries**: put them on module path as **automatic modules**, later as **named modules**                           | Used from the start for **main app** and its dependencies (automatic or named modules)                                                  |
| Automatic modules role            | First step: move libraries to module path → become **automatic modules**; app (unnamed) consumes them                               | Non-modular dependencies of the main app are put on module path → **automatic modules** required from the app’s `module-info`           |
| Named modules (your code)         | Add `module-info.java` to **core libs** first; after base is stable, add `module-info.java` to the app                            | Add `module-info.java` to **main app** first; then gradually add `module-info.java` to service, repo, util layers                       |
| Dependency graph cleanliness      | Cleaner **foundation**: shared libs stabilised before app depends on them as named modules                                         | Graph starts from the top; may need to adjust modules as you modularise lower layers                                                    |
| Pros (short)                      | Solid base, fewer surprises later; good when libraries are messy or many shared components                                        | Early use of JPMS at app level; clearer high-level module graph; business-facing module is modular early                                |
| Cons (short)                      | Longer before you run app as a module; remains on class path for a while; less visible “modular” progress                         | Need to juggle automatic modules and possible unnamed-module bridges early; may hit legacy issues (reflection, split packages) sooner   |
| When it’s preferred (exam)        | Question stresses **stabilising libraries/platform** first, cleaning shared code, or heavy legacy/3rd‑party libraries             | Question stresses **migrating the main app to modules quickly**, visibility of module graph, or running app via `java -m` early         |
| Unnamed module definition         | Special module containing **everything on class path**; **reads all named modules**, is **not read by them by default**          | Same definition; used mainly as a **temporary home for remaining legacy** while the main app and modules move to module path            |
| Automatic module definition       | JAR on **module path without `module-info`**; gets a **module name**, **reads all modules**, **exports all packages**             | Same definition; heavily used as a **bridge** for non‑modular dependencies of the modularised main app                                  |
| Core exam soundbite (bottom-up)   | “Keep app in the unnamed module; move libraries to module path as automatic / named modules; modularise app last.”               |                                                                                                                                           |
| Core exam soundbite (top-down)    |                                                                                                                                     | “First modularise the main app on the module path using automatic modules for dependencies; modularise those dependencies over time.”   |
